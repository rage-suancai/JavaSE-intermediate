package javaSE.javase14;

/**
 * 哈希表
 * 通过前面的学习 我们发现 顺序表虽然查询效率高 但是插入删除有严重表更新的问题 而链表虽然弥补了更新问题 但是查询效率实在是太低了 能否有一种折中方案 哈希表
 *
 * 不知大家在之前的学习中是否发现 我们的Object类中 定义了一个叫做hashcode()的方法 而这个方法呢
 * 就是为了更好地支持哈希表的实现 hashcode()默认得到的是对象的内存地址 也就是说 每个对象的hashCode都不一样
 *
 * 哈希表 其实本质上就是一个存放链表的数组 那么它是如何去存储数据的呢? 我们先来看看长啥样:
 *
 * 数组中每一个元素都是一个头节点用于保存数据 那么我们怎么确定数据应该放在哪一个位置呢? 通过hash算法 我们能够瞬间得到元素应该放置的位置
 *                  // 假设hash表长度为16 hash算法为:
 *                  private int hash(int hashcode) {
 *                      return hashcode % 16;
 *                  }
 *
 * 设想这样一个问题 如果计算出来的hash值和之前已经存在的元素相同了呢? 这种情况我们称为hash碰撞
 * 这也是为什么要将每一个表元素设置为一个链表的头节点的原因 一旦发现重复 我们可以往后继续添加节点
 *
 * 当然 以上的hash表结构只是一种设计方案 在面对大额数据时 是不够用的 在JDK1.8中 集合类使用的是数组+二叉树的形式解决的
 * (这里的二叉树是经过加强的二叉树 不是前面讲的简单二叉树 我们下一节就会开始讲)
 */
public class Main {

    public static void main(String[] args) {



    }

}
